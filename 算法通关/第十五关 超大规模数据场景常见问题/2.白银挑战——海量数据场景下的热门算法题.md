# 2.白银挑战——海量数据场景下的热门算法题

本文，我们来详细看几道经常出现的海量数据场景下的查找问题



| **关卡名**                                         | 海量数据场景下的热门算法题       | 我会了✔️ |
| -------------------------------------------------- | -------------------------------- | ------- |
| **内容**                                           | 1.从40个亿中产生一个不存在的整数 |         |
| 2. 用 2GB 内存在 20 亿个整数中找到出现次数最多的数 |                                  |         |

# 1.从40个亿中产生一个不存在的整数

题目要求：给定一个输入文件，包含40亿个非负整数，请设计一个算法，产生一个不存在该文件中的整数，假设你有1GB的内存来完成这项任务。

- 进阶：如果只有10MB的内存可用，该怎么办？

本题不用写代码，如果能将方法说清楚就很好了 ，我们接下来一步步分析该如何做。

## 1.1 位图存储大数据的原理

假设用哈希表来保存出现过的数，如果 40 亿个数都不同，则哈希表的记录数为 40 亿条，存一个 32 位整数需要 4B，所以最差情况下需要 40 亿*4B=160 亿字节，大约需要16GB 的空间，这是不符合要求的。

40 亿*4B=160 亿字节，大约需要16GB 

40 亿/8 字节=5亿字节，大约0.5GB的数组就可以存下40亿个。

如果数据量很大，采用位方式（俗称位图）存储数据是常用的思路，那位图如何存储元素的呢？ 我们可以使用 bit map 的方式来表示数出现的情况。

具体地说， 是申请一个长度为 4 294 967 295(500MB*8) 的 bit 类型的数组 bitArr（就是boolean类型），bitArr 上的每个位置只可以表示 0 或1 状态。8 个bit 为 1B，所以长度为 4 294 967 295 的 bit 类型的数组占用 500MB 空间，这就满足题目给定的要求了。

那怎么使用这个 bitArr 数组呢？就是遍历这 40 亿个无符号数，遇到所有的数时，就把 bitArr 相应位置的值设置为 1。例如，遇到 1000，就把bitArr[1000]设置为 1。

遍历完成后，再依次遍历 bitArr，看看哪个位置上的值没被设置为 1，这个数就不在 40 亿个数中。例如，发现 bitArr[8001]==0，那么 8001 就是没出现过的数，遍历完 bitArr 之后，所有没出现的数就都找出来了。

位存储的核心是：我们存储的并不是这40亿个数据本身，而是其对应的位置。这一点明白的话，整个问题就迎刃而解了。

## 1.2 使用10MB来存储

如果现在只有 10MB 的内存，此时位图也不能搞定了，我们要另寻他法。这里我们使用分块思想，时间换空间，通过两次遍历来搞定。

40亿个数需要500MB的空间，那如果只有10MB的空间，至少需要50个块才可以。

一般来说，我们划分都是使用2的整数倍，因此划分成64个块是合理的。

首先，将0~4 294 967 295(2^32) 这个范围是可以平均分成 64 个区间的，每个区间是 67 108 864 个数，例如：

- 第0 区间（0~67 108 863）
- 第 1 区间（67 108 864~134 217 727）
- 第 *i* 区间（67 108 864**i*~67 108 864*(*i*+1)-1），
- ……，
- 第 63 区间（4 227 858 432~4 294 967 295）。

因为一共只有 40 亿个数，所以，如果统计落在每一个区间上的数有多少，肯定有至少一个区间上的计数少于67 108 864。利用这一点可以找出其中一个没出现过的数。具体过程是通过两次遍历来搞定：

第一次遍历，先申请长度为 64 的整型数组 countArr[0..63]，countArr[i]用来统计区间 *i* 上的数有多少。遍历 40 亿个数，根据当前数是多少来决定哪一个区间上的计数增加。例如，如果当前数是 3 422 552 090 ， 3 422 552 090/67 108 864=51 ， 所以第 51 区间上的计数增加countArr[51]++。遍历完 40 亿个数之后，遍历 countArr，必然会有某一个位置上的值（countArr[i]） 小于 67 108 864，表示第 *i* 区间上至少有一个数没出现过。我们肯定会找到至少一个这样的区间。

此时使用的内存就是countArr 的大小（64*4B），是非常小的。

假设找到第 37 区间上的计数小于 67 108 864，那么我们对这40亿个数据进行第二次遍历：

1. 申请长度为 67 108 864 的 bit map，这占用大约 8MB 的空间，记为 bitArr{0..67108863}。
2. 遍历这 40 亿个数，此时的遍历只关注落在第 37 区间上的数，记为 num（num满足num/67 108 864==37），其他区间的数全部忽略。
3. 如果步骤 2 的 num 在第 37 区间上，将 bitArr{num - 67108864*37}的值设置为 1，也就是只做第 37 区间上的数的 bitArr 映射。
4. 遍历完 40 亿个数之后，在 bitArr 上必然存在没被设置成 1 的位置，假设第 *i* 个位置上的值没设置成 1，那么 {67 108 864*37+*i}* 这个数就是一个没出现过的数。

总结一下进阶的解法：

1. 根据 10MB 的内存限制，确定统计区间的大小，就是第二次遍历时的 bitArr 大小。
2. 利用区间计数的方式，找到那个计数不足的区间，这个区间上肯定有没出现的数。
3. 对这个区间上的数做 bit map 映射，再遍历bit map，找到一个没出现的数即可。

## 1.3 如何确定分块的区间

在上面的例子中，我们看到采用两次遍历，第一次将数据分成64块刚好解决问题。那我们为什么不是128块、32块、16块或者其他类型呢？

这里主要是要保证第二次遍历时每个块都能放进这10MB的空间中。2^23<10MB<2^24,而2^23=8388608大约为8MB，也就说我们一次的分块大小只能为8MB左右。在上面我们也看到了，第二次遍历时如果分为64块，刚好满足要求。

所以在这里我们最少要分成64块，当然如果分成128块、256块等也是可以的。

# 2. 用 2GB 内存在 20 亿个整数中找到出现次数最多的数

更多高频问题，仅限报名[【编程导航 - 算法通关村】](https://yuyuanweb.feishu.cn/wiki/J9qLwpv75iropZkXpmIcYrZ8nNM) 的同学可见，点击了解详情并参与.....





#  通关文牒

本题介绍了几道非常典型的海量数据处理的问题，这些题目一般只要将原理说清楚就好，面试的时候不用写代码。

针对本题写一篇博客，题目为《算法通关村——***的处理方法》.视为过关。
![](https://pic.yupi.icu/5563/202311220828982.png)
