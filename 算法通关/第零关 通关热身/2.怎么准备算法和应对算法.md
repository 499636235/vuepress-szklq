# 2.怎么准备算法和应对算法

本文我们先来聊一聊算法的边界再哪里，如何准备算法，以及如何刷算法题

# 1. 算法的边界是什么

## 1.1 算法到底考什么

上面说了这么多，那算法到底考察什么呢？我们来分析一下。

首先算法有校招和社招两种情况，校招算法的首要目的是什么呢？刷人！每年投阿里头条的可能有十万几十万，面试官不能一个个去面吧，那怎么办呢？用一些难的算法干掉一大波人，剩下的再择优录取，所以你在网上看到的什么阿里秋招、头条春招试题集里的算法都挺难。

而对于社招，或者校招的时候扛过了笔试进入了面试环节，只要你简历筛选通过了，就说明他愿意放下各种外在因素，考察一下这个人的功力如何，能力怎么样，而算法只是考察思维能力的一部分，不是为了刷人而刷人，因此不会像校招这么变态。

在面试的时候还要考虑时间因素，两个小时还没写出来，面试官自己都坐不住了。要知道面试官也是开发者，他可能正在忙着做需求、查bug，只是被HR临时叫来面试，他能接受的算法时间也就半小时左右。因此社招面试会以中等问题为主，时间在20~40min为主。

社招面试考点主要有三个：

- 这个人的编程基本功是否扎实，基本功不扎实，写的代码可能到处是bug；
- 这个人的编码规范性如何，如果很混乱，边界、异常等处理不清楚，那承担的任务肯定让人不放心的；
- 这个人思维能力如何，是否能短时间内解决问题。这反应的就是平时遇到问题是否能够很好的解决掉，而不是天天无能为力。

由此面试算法的特点是：

1.能够让面试者在20~40min左右完成。

2.基本数据结构的变型题，有思维含量，但不会太难太偏。

3.代码精简，50行以内就能解决问题。

根据上面三点，我们就可以认为不是所有算法都会考，刷算法也不是什么都刷，而应该更有针对性。看三个美团的例子：

![](https://pic.yupi.icu/5563/202311211318462.png)

自己经历的例子：

![](https://pic.yupi.icu/5563/202311211318112.png)

这几个问题感觉如何？其实都是基本数据结构的拓展，不是晦涩难懂的动态规划什么的。这类题目在算法中能占到80%以上，所以大部分情况下只要掌握这些基本内容，就不用怕大部分的算法面试。

## 1.2 什么时候会出现难题呢？

有以下几种情况：

1.校招的时候，上面已经说了，不再赘述。

2.有些公司会先让你做个笔试题，或者提前上机写算法，通过之后才通知你去面试。这时候面试官不用考虑浪费自己时间的问题，可以给你两三个小时让你一直做，那这时候算法题的难度就会高很多。

3.面试官不喜欢你，想让你走，可能会说你水平不错，但是我们更需要高级开发工程师等等。这不扯淡吗？招聘公告里压根就没说好不。 或者公司都快不行了，招人只是个噱头。公司的起起伏伏、生生死死太厉害了，比如今年去滴滴面，你觉得他们是真的需要人吗？这也说明，很多时候不见得是你的问题，而是对方的问题。

4.面试官不会出题，我们不要觉得自己来面试就低人一等，面试是双向选择的过程，很可能是面试官经验不够不会出题，这就导致题目比较偏。

而我们在网上经常看到某某地方算法变态、或者直接抛出一个巨难无比的算法，说是哪里的面试题，问怎么做。这种信息就是垃圾，连搭理的必要都没有。

你绝对不会因为清华北大的考试难就不让你孩子上学吧？你也绝不会为了去大厂将所有的算法都学会吧。你也绝不会有百分之百的把握才会出去面试吧。我们学习更多是为了将算法面试的成功率从全靠运气变成80%的题目都会做，这就够了。

那该掌握多少算合适呢？

我的观点是数据结构以及相关变形、拓展问题要掌握，大约150道核心题目。

高级专题要掌握滑动窗口、BFS、前缀树、数字和部分数学问题、回溯、贪心、动态规划等等大约200道核心题目。

假如超出这些呢？实在做不来该怎么办呢？先尽力而为，不行就直接走人。这个公司很好吗？给的很多吗？加班很少吗？不然的会凭什么让我花那么多精力准备没用的算法! 所以实在没办法，就当走路的时候踩到狗屎了，换个公司继续面。

## 1.3 算法的来源

很多东西难只是我们感觉难，如果明白其体系结构，循序渐进学习，很多事情就没那么难了。我们现在就看一下算法的体系到底是什么。要看体系，我们要先知道算法题是怎么来的，例如LeetCode2500多道题都是怎么来的。

我们经常看到”数据结构与算法“这样的名字，算法就是解决具体问题的步骤，例如遇到喜欢的女孩子，怎么追就是个算法问题；为了不迟到，你需要几点出门也是算法问题。算法更多的是思想，而数据结构是实现算法的载体，不管你的算法多么复杂，如果要计算来处理，最后都要落实到数组、链表、树、图等基本的结构上。

从上面这个关系，就可以看到算法命题的两条主线。第一条是基于数据结构的基本操作进行组合、变换和拓展。例如链表有增删改查四种基本操作，组合一下就有了经典的链表反转问题，这个问题长期霸占算法面试top1的位置，而链表反转又可以变换出指定区间反转、K个一组反转、两两反转等问题。还可以继续拓展出链表相加等算法问题。

事实上，所有数据结构的基本操作都是增删改查，基于此可以拓展出大量的问题，LeetCode中有一大半的题目都是这么来的。而这些问题难易适中、题干精简，非常适合面试，因此这也是我们后面学习的重点。

现实中，一个问题一个解法，但是很多问题的处理思路往往是一样的，所以很多人不断将一些通用方法进行总结和归纳就产生了针对特定场景的解题思想。例如暴力也无法解决的问题可以考虑使用回溯思想，为了防止数组中频繁对大量元素进行移动而产生了”双指针思想“。而将一些常用思想汇集起来就是我们常说的算法，例如广度优先搜索、深度优先搜索、滑动窗口、回溯、贪心、动态规划等等。这类问题往往比较难一些，关键在于我们对这些思想的理解没那么透彻，对其适用范围和常见问题也不太清楚，所以才会觉得难。

上面两种是绝大部分算法的来源，也是我们学习的重点。除此之外，还有两种常见的途径：

第一个，算法是个巨大的数学问题，比如数学里有《数论》《矩阵论》《概率论》《图论》《离散数学》《数值计算》《近世代数》《有限域》《最优化算法》等等，而如何用代码实现，都可以作为一个算法问题。但是这些领域过于专业的东西，我们基本用不到，常用的也就一些基本的内容。所以将这些科目的基本问题聚合到一起，就变成了算法的常见考题。例如在《数学》一章，我们只会涉及初等数论、位运算和矩阵等一些基本问题，而不会去研究有限元、椭圆曲线方程这些。这类题目在面试中占比不算高，但是在校招中不少。

其次，就是根据很多实际问题抽象而来，各个大厂对外公开的算法题里大量存在这种问题。例如小米的《风口的猪-中国牛市》、美团的《病毒传播》、快手的《获得最多的奖金》等等。这些问题灵活多变，需要我们根据文字描述建立模型，最后再编码实现，因此难度一般来说要大一些。这类问题一般出现在笔试或者加试过程中，进入面试环节了，就不用管了。

# 2 如何刷题

我们明确了范围之后，接着就是按图索骥，逐个突破了，具体来说，在刷题的时候有以下几点方式会大大提高学习的效果。

## 2.1 按照专题刷，一招多题

首先，目前公认最好的刷算法就是按照主题来进行，这也是最科学的方法。例如双指针系列、链表反转系列等等。算法题的聚集效应非常明显的，例如二叉树的层次遍历搞定了，连续十几道相关题目看一看就行了。而会了一个滑动窗口的模板，连续12道算法题也一晚搞定。这样坚持一段时间之后，再做新题就是不断完善自己的这个体系，而不是越做越糊涂。 

一个好的课程自然是要帮你梳理清楚这些专题，让你用最短的时间就能掌握，这也是我们课程一直在努力做的事。

## 2.2 用大白话理解问题

算法不会，我们会感觉是自己不行，但是很多时候是因为别人写的东西为了提高逼格，弄的高大上。最典型的就是罗列一堆晦涩词汇。很多人一看动态规划就想着最优子结构，一看滑动窗口就盯着“循环不变量”不放，一提到红黑树就开始讲5大特征，那一定是学不好的。因为专业名词是减少专业人士之间的废话的，而不是给小白看的。我认为这也是国内很多教材让人看不懂的一个重要原因。如果你对孩子反反复复说“大型雌性猫科动物”，你解释一天他也不知道你在说啥，而找个母老虎的照片给他看一下，秒懂！

所以说，很多时候学不会，不是傻*，而是写材料的人在装*。如果从问题的本源开始梳理，很多东西都是很简单的。比如动态规划里的记忆化搜索，不过就用了一个数组保存已经计算出来的结果而已，而回溯代码的框架不过是遍历N叉树而已。

在我们的课程里，我会努力用最易懂的语言来解释算法。这是一个持续的过程，相关的工作我一直在做。

## 2.3 多画图，每个题目就是一个图

任何算法都是一个图，可能是结构图，也可能是时序图，只有这个图在大脑里构造出来了，我们才真的明白，与看了多少文字，刷了多少题目关系不大。而且只有图能在大脑里长期存在，如果脑子里想清楚了，下次面试时，找来复习一下就行了。

这里解释了一个问题，就是学到什么程度才叫”学到家了“呢？有时候我们会感觉虽然学了一遍，但还是不放心，总感觉还是不会。我认为一个标准就是是否将这个问题的图在大脑里勾勒清楚了。比如二叉树的层次遍历执行过程是什么样的？元素大致怎么移动的？怎么来将每层分开？这些想清楚了，过几个月仍然会记得。而不是每行代码都记得才叫练算法。

图勾勒出来之后，我们以后换工作花在算法上的时间精力会越来越少。我们自然可以拿更多时间准备架构等更高级的东西，所以才能要更高的薪资，而不是每次都为基本问题搞不定而浪费时间。

我们的课程里也一直在努力做到这一点，不过这是一个庞大的工作，课程中会有一些瑕疵，如果发现问题了，请及时和我说。 

## 2.4 先在纸上手写，再上机

这是我的个人感受，很多人一看算法就打开LeetCode开始调，要知道程序要在LeetCode里运行起来要解决环境、定义、边界以及几十个case都过才行，这并不是一个简单的事情，很多时候我们只能跑通几个case。在学习算法的初期，我们不必太介意过了几个case，而应该先关注我们是否将算法的思想理解清楚了，因此在纸上手写，或者使用Idea、pyCharm这种编译环境测试几个case就可以了。

# 3 面试时怎么写算法

面试虽然在考算法，但是更多是考察思维水平的，而且很多面试官靠的是对你的感觉，感觉不好，即使最后写出来了也不一定会要。因此要注意与面试官交流，让其有个好的面试体验，否则就会随便找个理由将你打发走。比较可行的操作是：

- 第一步：理解问题，复述问题进而明确问题。

面试官说完之后，不要急着写，而是先复述一下你对问题的理解，这样可以防止理解错误，平时我们做需求也是这样的逻辑。

- 第二步：进一步确认问题，并大胆说出想法，逐步找到最优想法。

很多面试官不见得会将问题描述很清楚，这时候你的思考和引导会极大影响面试官对你的认可程度。例如：

```plain
面试官：请设计一种列表排序算法。
求职者：具体是哪种列表，数组还是链表？
面试官：数组
求职者：数组里放的是什么？数字、字符还是其他的。
面试官：数字。
求职者：这些数组都是整数吗？
面试官：是的
求职者：这些数字是随机的还是年龄等这些特殊场景的。
面试官：顾客年龄。
求职者：总共有多少顾客。
面试官：百万级
```

这时候我们会发现问题与我们最初理解的非常不一样，对一个包含一百万条年龄进行排序和对100个随机的数据排序方法会差很多很多。很多人会上来就想到教科书上的几种排序方法，那就错了。

确定了之后，那这时候我们就可以在大脑里快速想一下所有的数据结构、算法思想，想想哪些能解决这个问题。对于本题，人的年龄一般不会超过150岁，因此创建一个大小为150的数组，索引就是年龄，值就是统计值，遍历一下这一百万就可以得到最终结果。

将这个想法和面试官说了之后他没有异议才可以写，反之则必须先努力想，直到想清楚再下笔。

- 第三步：初步设计，先写整体，再考虑边界

算法的设计可能会比较困难，我们一时难以考虑周全，此时可以先将核心代码写出来，再逐步考虑忽略边界和一些异常情况，这个只能靠平时多积累。第一次写的时候不要怕乱，完成之后是可以和面试官打个招呼，然后重新誊写一遍的。

代码里重要的扣分点就是边界情况的处理和特殊场景的解决，很多人都会栽在这上面，如果有一个两个，面试还会提醒一下，如果太多，算法就废了。这个也只能靠平时的积累。在我们的讲义里会将每个算法可能的情况都告诉你。例如字符串转整数问题，看似简单，但是要处理五六种可能的情况，忘记两种就废了。

如果代码已经交给面试官了，你也要继续思考，如果发现哪里有问题，是可以直接和面试官说的，及时补救也是你思维活跃的表现。

- 第四步：测试检验，评判性能，优化解法。

如果是线上面试，很多时候算法是要能跑过的，测试的调试过程可能会麻烦不断，这时候只能硬着头皮上了。这时候一定要淡定，不用像热锅的蚂蚁一样这里修修那里改改，这样只会越来越乱，反而让面试官感觉你不行。

如果很幸运都跑过了，此时可以继续和面试官聊你想到的其他方法或者技巧，另外这时候经常会讨论一个非常重要的问题：时间复杂度和空间复杂度分析，这是评价算法好坏的重要指标，一般算法写完之后都会和面试官简单聊一下当前算法的复杂度情况。

平时刷算法的时候就要注意每个解法的时间复杂度和空间复杂度是什么。这其实是个比较简单问题，为了节省篇幅，我们大部分题目并没有太强调，但是自己刷题的时候要注意。

另外再强调一个问题，代码写的时候命名要专业一些，不要随便用 a ,b这种，尽量使用 int left,right等这种有意义的。命令问题很大程度反应了这个人的专业程度。在java里一般使用驼峰命令法，都使用英文单词，第一个单词全部小写，后面的单词首字母大写。




![](https://pic.yupi.icu/5563/202311211318190.png)