# 4.时间复杂度和空间复杂度问题

本文我们来理解一个非常重要的概念，复杂度问题。这个概念其实很简单 很多人经常感到很蒙，本文我们就来白话讲讲。

面试的时候怎么考呢？一般有两种方式：

1.一个是要求你的算法满足特定的时间或者空间复杂度要求。例如同一个问题，有的解法时间复杂度是O(n^2),有的是O(n)，那这时候面试官可能会要求你的算法时间复杂度满足O(n)，或者空间复杂度满足O(1)。这时候你要理解面试官的意思。

2.让你对不同的实现方式的做评判，典型的是不同的排序有不同的复杂度，让你来评判，详见排序一关。 

# 1 时间复杂度

## 1.1 算法如何度量

看新闻，我们经常听到GDP，国内生产总值，这个是衡量经济发展状况的基本指标。在公司里，经常听到KPI考评等指标。所以很多事物都需要一个相对客观的衡量标准来评价好坏或者差异。对于算法，最重要就是时间复杂度和空间复杂度。

例如求累加和的算法，先看依次累加的执行过程：

```java
void addOneByOne() {
    int sum = 0, n = 100;   //执行1次
    for (int i = 0; i <= n; i++) { //执行了n+2次，最后一次判断不再满足要求，跳出
        sum = sum + i;      //执行n+1次
    }
    System.out.println("result is :" + sum); //执行1次
}
void addOneByOne() {
    int sum = 0, n = 100; // 执行1次
    for (int i = 0; i <= n; i++) { // 执行了n+2次，最后一次判断不再满足要求，跳出
        sum = sum + i; // 执行n+1次
    }
    printf("result is: %d", sum); // 执行1次
}
def addOneByOne():
    sum = 0
    n = 100
    for i in range(n + 1):
        sum += i
        if i == n:
            break
    print("result is:", sum)
```



我们知道，也可以直接使用公式的执行过程：

```java
void addByFormula() {
    int sum = 0, n = 100;   //执行1次
    sum = (1 + n) * n / 2;  //执行1次
    System.out.println("result is :" + sum);//执行1次
}
void addByFormula() {
    int sum = 0, n = 100;  // 执行1次
    sum = (1 + n) * n / 2;  // 执行1次
    printf("result is: %d", sum);  // 执行1次
}
def addByFormula():
    sum = 0
    n = 100
    sum = (1 + n) * n / 2
    print("result is:", sum)
```



显然第一种执行了1+(n+2)+n+1=2n+4次，而第二种只执行了3次，好坏立见。

假如上面改成一个100X100的二维数组，数组的每一行都是1到100，那么这时候该如何做呢？很明显仍然有累加和乘法两种方式。累加法:

```c
void addOneByOne(int arr[][n], int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            sum += arr[i][j];
        }
    }
    printf("result is: %d", sum);
}
void addOneByOne(int arr[][], int n) {
    int sum = 0;   
    for (int i = 0; i < n; i++) {  
        for (int j = 0; j < n; j++) 
        sum = sum + arr[i][j];      
    }
    System.out.println("result is :" + sum); 
}
def add_one_by_one(arr, n):
    sum = 0
    for i in range(n):
        for j in range(n):
            sum += arr[i][j]
    print("result is:", sum)
```



而公式法则容易很多：

```c
void addByFormula(int arr[][n], int n) {
    int sum = 0;
    sum = (1 + n) * n * n / 2;
    printf("result is: %d", sum);
}
void addByFormula(int arr[][], int n) {
    int sum = 0;   //执行1次
    sum = (1 + n) * n * n / 2;  //执行1次
    System.out.println("result is :" + sum);//执行1次
}
sum = (1 + n) * n * n // 2
print("result is:", sum)
```

可以看到累加的执行次数远远高于公式法的执行次数，这个差异就更明显了，所以执行的步骤数是考察算法好坏的一个重要标准。

我们要记住一句话：时间复杂度的时间指的是用语句的执行次数，而不是实际的时间。我们知道计算机执行乘除运算是非常消耗资源的，而加减则计算很快，因此上面的例子不能说两者执行的时间差为2n^2+4n+2，因此时间复杂度只是一个简化的描述。

除了用次数表示时间进行简化，还有一个系数和参数方面的简化。上面的例子中我们找到了非常准确的描述计算次数的方法，但是其实我们更关心当元素数量非常大时的变化情况。

例如y=x+1,当x非常大时，1就可以忽略不计了，我们可以只保留y=x。

而如果y=x^2+x，当x非常大时，后面的+x作用也不大了，我们可以只保留y=x^2。

同理，y=3x^2和y=x^2+x+4 ，当x非常大时，此时前面的系数3和4的影响也不大，我们仍然可以只保留y=x^2。

此时我们可以只考虑不同的阶之间的变化情况，如下可以看到过了1之后，不同的表达式的差异将非常巨大。

![](https://pic.yupi.icu/5563/202311211320372.png)

所以上面我们可以将表达式分别简化为y=1，y=x和y=x^2，也就是1阶，线性阶和平方阶。

![](https://pic.yupi.icu/5563/202311211321957.png)

要严格证明其关系需要考虑到渐近函数等数学问题，在很多算法书中有详细的解释，但是这个在算法面试中用不到，因此不再展开，只认为是简化就好了，这种表示就是O()记法。例如：

![](https://pic.yupi.icu/5563/202311211320185.png)

我们需要记住的是常见的阶耗费时间的关系是：

![](https://pic.yupi.icu/5563/202311211320879.png)

后面我们在表述算法的好坏一般都是直接说是上面的O(*)，而不会具体计算到底是多少。

## 1.2 几种常见的阶

虽然我们不需要证明上面的结论，但是在写算法的时候要能够判断当前代码的阶是多少，特别是O(logn)，所以我们本节来看一下如何计算阶。

我们要明确一点，时间复杂度针对执行的次数与问题的规模之间的关系来看的。如果只有常数个，不管是10个还是100个，都是常数阶。而如果问题的规模为n，并能够表示规模比较大的情况才会有前面说的近似等价的情况。如果执行次数随着问题规模线性增加就是线性阶，等等。

常见的阶如下：

#### (1)常数阶

一般顺序执行并且只执行一次的代码就是常数阶，例如上面的sum=（1+n）*n/2。

如果是这样的代码：

```plain
sum=sum+1;
sum=sum+2;
sum=sum+3;
sum=sum+4;
```

sum=sum+1;执行了4遍，即使重复了100次，也都是常数级，都用O(1)表示。

#### (2)线性阶

线性阶表示执行的次数随着问题规模是线性变化的，例如下面的格式:

```plain
for(int i=0;i<n;i++){
   i++;
}
```

还有while循环:

```plain
while(i<n){
   i++;
   //todo
}
```

这里很显然执行todo的次数随着n是线性变化的，因此是线性阶。

#### (3)平方阶

平方阶主要是双层循环嵌套。

```plain
int i,j;
for(i=0;i<n;i++){
 for(j=0;j<n;j++){
    //todo 时间复杂度为1的程序
    todo 
 }
}
```

上面的todo随着n是呈平方级别增加的，n是2，就执行4次，n是3就执行9次，所以是平方阶。

这个问题我们还可以改一下，将代码换成这样子：

```plain
int i,j;
for(i=0;i<n;i++){
 for(j=i;j<n;j++){
    //todo 时间复杂度为1的程序
    todo 
 }
}
```

此时执行的次数明显只有上面的一半，但是从级别看，仍然是平方阶，只不过执行次数只有一半了，如果感觉不好理解，可以看下面Yovvis同学画的图：

![](https://pic.yupi.icu/5563/202311211320036.png)

#### (4) 对数阶

例如在后面要学习的二分查找，二叉树等问题经常会看到O(logn)。

其本质都可以简化成如下模型:

```plain
int count=1;
n=64
int items=0;
while(count<n){
   count=count*2;//todo注意看的是这行的执行次数与n的关系
   itmes++;
} 
```

这个问题很多人总是想不明白，凡是处理时间复杂度，一定要注意一点：那就是代码体与循环结束条件之间的关系。

在上面的例子里，我们可以看一下todo的执行次数与count<n之间的关系:

| todo执行次数 | 第一次 | 第二次 | 第三次 | 第四次 | 第五次 | 第六次 | 第七次 |
| ------------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| count        | 1      | 2      | 4      | 8      | 16     | 32     | 64     |

从上面可以看到，如果todo要执行第七次时，已经不满足count<n了，所以执行次数与n的关系正好是

2^x=n，也就是x=logn。

所以说，二分查找不过是每循环一次都是减半.所以todo的执行次数是logn次。

# 2 时间复杂度练习

设n为正整数，试确定下列各程序段中前置以记号@的语句的频度：

**第一题**

```plain
 i=1; k=0;
    while(i<=n-1){
        @  k += 10*i;
           i++;
    }
```



**第二题**

```plain
int i=1 ,k=0;
    do {
        @  k += 10*i;
           i++;
    } while(i<=n-1);
```

**第三题**

```plain
(3) i=1; k=0;
    while (i<=n-1) {
              i++;
        @ k += 10*i;
    }
```

**第四题**

```plain
(4) k=0;
    for(i=1; i<=n; i++) {
        for(j=i; j<=n; j++)
            @  k++;
    }
```

**第五题**

```plain
(5) for(i=1; i<=n; i++) {
        for(j=1; j<=i; j++) {
            for(k=1; k<=j; k++)
                @  x += delta;
    }
```

**第六题**

```plain
(6) i=1; j=0;
    while(i+j<=n) {
         @ if(i>j) 
             j++;
              else
              i++;
    }
```

**第七题**

```plain
(7) x=n; y=0;    
    while(x>=(y+1)*(y+1)) {
        @  y++;
    }
```

**第八题**

```plain
(8) x=91; y=100;
    while(y>0) {
        @  if(x>100) 
          { x -= 10; 
             y--; 
          }
          else 
           x++;
```

解析：

![](https://pic.yupi.icu/5563/202311211320312.png)

# 3 最坏情况和平均情况

我们可以设想一个场景，早上上班的时候，你出门时找不到手机了，然后就回家来取，手机就在床头，你穿鞋时忘拿了，所以拿了就走，基本没花时间。但是有时候你压根不知道放哪里去了，你不得不将所有的地方都找了一遍， 花了两个小时，最后发现被你的猫咪叼到窝里去了。第二次又遇到类似的情况，怎么也找不到手机了，但你的女朋友来你家撸猫，所以她用手机打了一下，你就知道手机被叼到猫砂盆里去了。

上面这三种情况就很形象的说明了，最好情况、最差情况和平均情况。算法分析也有类似的问题，我们查找的时候有n个随机数字，最好的情况是我们访问的第一个正好就是要找的，最坏的情况是将所有的数据查一遍才找到。不过大部分情况下我们都是在中间某个位置找到，因此这三种情况恰好反应了算法的上下边界和平均状态。我们后面分析排序等算法时一般都会 考虑某种算法的平均水平怎么样、最坏情况怎么样，而具体如何判断，我们后面具体情况具体分析。

# 4 空间复杂度

上面谈论的都是时间复杂度，还有一个是空间复杂度。这个非常简单，就看需要申请多少额外的空间来做现在的事情，例如你需要申请一个或者两三个变量，那么空间复杂度就是O(1)，如果需要申请一个数组，链表、队列、栈或者Hash，其空间复杂度都是O(n)，如果需要申请一个二维数组就是O(n^2)。其他的极少用，你申请O(n^2)就已经到面试官能接受的极限了。


![](https://pic.yupi.icu/5563/202311211320800.png)