# 1.青铜挑战——字符串：隐形的王者

字符串本身不是一种数据结构，但是由于其本身的特殊性，可以产生很多特殊的算法题。

字符串在工程里也有非常广泛的应用，因此字符串是真正的隐形王者，一直都是算法考察的重点问题之一，我们有必要认真研究一下相关的问题。



| **关卡名**                                  | 字符串：隐形的王者     | 我会了✔️ |
| ------------------------------------------- | ---------------------- | ------- |
| **内容**                                    | 1.理解字符串的基本特征 |         |
| 2.记住Java、C或者Python里字符串都是怎么用的 |                        |         |
| 3.掌握字符串转整数的几种场景和处理方法      |                        |         |

字符串本身不是一种数据结构，但是由于其本身的特殊性，可以产生一些特定的算法题。而C、java等语言创建和管理字符串的方式也都有差异，因此针对语言特征又产生了很多问题，这些问题可以做为算法面试的一部分，也可以作为技术面试的一部分。

在链表、数组等结构中，元素之间没有语义的关联的，但是字符串则不同，前后几个字母组合在一起就是一个单词，这时候，我们可以从字母的角度、单词的角度等组合出很多花样来，这也是为什么字符串题目特别多的原因之一。

字符串里存放的可以是字母，可以是数字，也可以是特殊字符，字母又可以大写和小写，这就导致字符串有一类关于转换的题目，这些题目无非就是这几种类型的相互转换。

在处理转换过程中需要处理几种特殊情况：例如首先就是转之前先判断当前元素能不能转。如果是字符串转数字，则要考虑当前元素是不是数字。转完之后会不会溢出等。这些问题本身不复杂，但是必须考虑周全 ，如果考虑不周，就是面试时的扣分点了。

我们看几个题目：

# 1.转换成小写字母

LeetCode709. 给你一个字符串 s ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。

```plain
示例1：
输入：s = "Hello"
输出："hello"

示例2：
输入：s = "here"
输出："here"

示例3：
输入：s = "LOVELY"
输出："lovely"
```

我们知道每个字母都是有确定的 ASCII的，因此我们可以根据 码表操作字符串即可。常见ASCII范围是：a-z：97-122 A-Z：65-90 0-9：48-57 

这个题可以先遍历整个字符串，然后对每一位字符进行判断，如果str[i]的值在A-Z之间，则需要在原来的基础上ASCII码加上32即可转换成对应小写：

```java
public static String toLowerCase(String s) {
    int n = s.length();
    char[] chars = s.toCharArray();
    for (int i = 0; i < n; ++i) {
        if (chars[i] >= 65 && chars[i] <= 90) {
            chars[i] += 32;
        }
    }
    String str = new String(chars);
    return str;
}
char* toLowerCase(char* s) {
    int i = 0;
    while (s[i] != '\0') {  // 遍历字符串直到遇到结束符 \0
        if (s[i] >= 'A' && s[i] <= 'Z') {  // 判断字符是否是大写字母
            s[i] += 32;  // 转换为小写字母
        }
        i++;
    }
    return s;
}
def toLowerCase(s):
    chars = list(s)  # 将字符串转换为字符列表
    for i in range(len(chars)):
        if ord(chars[i]) >= 65 and ord(chars[i]) <= 90:  # 判断字符是否是大写字母
            chars[i] = chr(ord(chars[i]) + 32)  # 转换为小写字母
    str = "".join(chars)  # 将字符列表转换为字符串
    return str

s = "Hello World"
print(toLowerCase(s))
```

# 2 字符串转换整数 (atoi)

**本题涉及到数字溢出的处理，我们在下一关讲解数学的时候再详细解释，这里先考验一下，看看自己能否想明白。**

LeetCode8. 本题的题目要求比较长，看原文：

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

函数 myAtoi(string s) 的算法如下：

```plain
* 读入字符串并丢弃无用的前导空格 
* 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
* 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
* 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
* 如果整数超过 32 位有符号整数范围 [−2^31,  2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。
* 返回整数作为最终结果。

**注意：**
- 本题中的空白字符只包括空格字符 `' '` 。
- 除前导空格或数字后的其余字符串外，**请勿忽略** 任何其他字符。
示例1：
输入：s = "42"
输出：42
解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
第 1 步："42"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："42"（读入 "42"）
           ^
解析得到整数 42 。
由于 "42" 在范围 [-2^31, 2^31 - 1] 内，最终结果为 42 。
输入：s = "   -42"
输出：-42
解释：
第 1 步："   -42"（读入前导空格，但忽视掉）
            ^
第 2 步："   -42"（读入 '-' 字符，所以结果应该是负数）
             ^
第 3 步："   -42"（读入 "42"）
               ^
解析得到整数 -42 。
由于 "-42" 在范围 [-2^31, 2^31 - 1] 内，最终结果为 -42 。
输入：s = "4193 with words"
输出：4193
解释：
第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："4193 with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）
             ^
解析得到整数 4193 。
由于 "4193" 在范围 [-2^31, 2^31 - 1] 内，最终结果为 4193 。
输入：s = "words and 987"
输出：0
解释：
第 1 步："words and 987"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："words and 987"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："words and 987"（由于当前字符 'w' 不是一个数字，所以读入停止）
         ^
解析得到整数 0 ，因为没有读入任何数字。
由于 0 在范围 [-2^31, 2^31 - 1] 内，最终结果为 0 。
输入：s = "-91283472332"
输出：-2147483648
解释：
第 1 步："-91283472332"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："-91283472332"（读入 '-' 字符，所以结果应该是负数）
          ^
第 3 步："-91283472332"（读入 "91283472332"）
                     ^
解析得到整数 -91283472332 。
由于 -91283472332 小于范围 [-2^31, 2^31 - 1] 的下界，最终结果被截断为 -2^31 = -2147483648 。
```

该题的要求很长，给的示例也很多，但是真正在面试的时候，这些要求是我们自己应该知道的，写代码也必须考虑的问题。面试官不会告诉你这些，如果你的代码考虑不周，他可能会提醒，如果提醒超过三次，你的代码就废了。

这个题最好不要用高级的特性，就是最基本的方式写。这里没有考察算法的知识，更多是开发中对数据的处理（如「参数校验」等）。如果面试中遇到，应先仔细阅读题目文字说明，认真细致的分析可能存在的情况，有疑问及时和面试官确认，千万不要阴沟里翻船。

在这里我罗列几个要点：

- 根据示例 1，需要去掉前导空格；
- 根据示例 2，需要判断第 1 个字符为 + 和 - 的情况，因此，可以设计一个变量 sign，初始化的时候为 1，如果遇到 - ，将 sign 修正为 -1；
- 判断是否是数字，可以使用字符的 ASCII 码数值进行比较，即 '0' <= c <= '9',如果0在最前面，则应该将其去掉；
- 根据示例 3 和示例 4 ，在遇到第 1 个不是数字的字符的情况下，转换停止，退出循环；
- 根据示例 5，如果转换以后的数字超过了 int 类型的范围，需要截取。这里不能将结果 res 变量设计为 long 类型，注意：由于输入的字符串转换以后也有可能超过 long 类型，因此需要在循环内部就判断是否越界，只要越界就退出循环，这样也可以减少不必要的计算；
- 由于涉及下标访问，因此全程需要考虑数组下标是否越界的情况。

特别注意：

1、由于题目中说「环境只能保存 32 位整数」，因此这里在每一轮循环之前先要检查，具体细节请见编码。

2、Java 、Python 和 C++ 字符串的设计都是不可变的，即使用 trim() 会产生新的变量，因此我们尽量不使用库函数，使用一个变量 index 去做遍历，这样遍历完成以后就得到转换以后的数值。

```java
public static int myAtoi(String str) {
    int len = str.length();
    char[] charArray = str.toCharArray();
    
    // 1、去除前导空格
    int index = 0;
    while (index < len && charArray[index] == ' ') {
        index++;
    }
    
    // 2、如果已经遍历完成（针对极端用例 "      "）
    if (index == len) {
        return 0;
    }
    
    // 3、如果出现符号字符，仅第 1 个有效，并记录正负
    int sign = 1;
    char firstChar = charArray[index];
    if (firstChar == '+') {
        index++;
    } else if (firstChar == '-') {
        index++;
        sign = -1;
    }
    
    // 4、将后续出现的数字字符进行转换
    // 不能使用 long 类型，这是题目说的
    int res = 0;
    while (index < len) {
        char currChar = charArray[index];
        // 4.1 先判断不合法的情况
        if (currChar > '9' || currChar < '0') {
            break;
        }
    
        // 这是解决溢出问题的经典处理方式，在下一关数学部分专门讲
        if (res > Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE / 10 && (currChar - '0') > Integer.MAX_VALUE % 10)) {
            return Integer.MAX_VALUE;
        }
        if (res < Integer.MIN_VALUE / 10 || (res == Integer.MIN_VALUE / 10 && (currChar - '0') > -(Integer.MIN_VALUE % 10))) {
            return Integer.MIN_VALUE;
        }
    
        // 合法的情况下，才考虑转换，每一步都把符号位乘进去
        // 想想这里为什么要带着sign乘
        res = res * 10 + sign * (currChar - '0');
        index++;
    }
    return res;
}
int myAtoi(string str) {
    unsigned long len = str.length();

    // 去除前导空格
    int index = 0;
    while (index < len) {
        if (str[index] != ' ') {
            break;
        }
        index++;
    }

    if (index == len) {
        return 0;
    }

    int sign = 1;
    // 处理第 1 个非空字符为正负符号，这两个判断需要写在一起
    if (str[index] == '+') {
        index++;
    } else if (str[index] == '-') {
        sign = -1;
        index++;
    }

    // 根据题目限制，只能使用 int 类型
    int res = 0;
    while (index < len) {
        char curChar = str[index];
        if (curChar < '0' || curChar > '9') {
            break;
        }
       // 这里是处理溢出的问题，在下一关数学部分专门讲
        if (res > INT_MAX / 10 || (res == INT_MAX / 10 && (curChar - '0') > INT_MAX % 10)) {
            return INT_MAX;
        }
        if (res < INT_MIN / 10 || (res == INT_MIN / 10 && (curChar - '0') > -(INT_MIN % 10))) {
            return INT_MIN;
        }

        res = res * 10 + sign * (curChar - '0');
        index++;
    }
    return res;
}
class Solution:
    def myAtoi(self, s: str) -> int:
        # 去除字符串两端的空格
        s = s.strip()

        # 判断字符串是否为空
        if not s:
            return 0

        # 判断第一个字符是否为正负号或数字
        if s[0] not in '+-0123456789':
            return 0

        # 判断正负号
        sign = 1
        if s[0] == '-':
            sign = -1
            s = s[1:]
        elif s[0] == '+':
            s = s[1:]

        # 将连续的数字字符转换为整数
        num = 0
        for c in s:
            if not c.isdigit():
                break
            num = num * 10 + int(c)

        # 处理正负号和溢出情况
        num = sign * min(num, 2**31 - 1) if sign == 1 else sign * min(num, 2**31)

        return num
```

上面这个实现确实能解决问题，但是太长了，我们可以使用jdk自带的库函数来简化部分操作，例如这里的去掉前导空格，我们就可以使用trim。

# 3 通关文牒

本篇介绍了字符串的两个很基本的转换题目，这里题目如果在面试遇到，应该不能丢分的。我们要记住字符串的常见操作，例如trim等等。另外第二题字符串转换成整数的问题， 涉及了多个重要场景的处理，是一道非常重要的问题，务必重视。



以第二道题目为基础，写一篇博客，题目为《算法通关村——不简单的字符串转换问题》视为通关。


![](https://pic.yupi.icu/5563/202311220823519.png)