# 2.白银挑战——位运算的高频算法题

与位运算和数学有关的题目真不少，而且很多都有一定的技巧，好在这些技巧相对是固定的，我们做好积累就行了。



| **关卡名** | 位运算的高频算法题            | 我会了✔️ |
| ---------- | ----------------------------- | ------- |
| **内容**   | 1.理解位运算如何统计1的个数的 |         |



# 1 位移的妙用

位移操作是一个很重要的问题，可以统计数字中1的个数，在很多高性能软件中也大量应用，我们看几个高频题目。

## 1.1 位1的个数

LeetCode191 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数。

拓展问题：16进制时怎么统计？

```plain
示例1：
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

示例2：
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```

首先我们可以根据题目要求直接计算，题目给定的 n 是 32 位二进制表示下的一个整数，计算位 1 的个数的最简单的方法是遍历 n 的二进制表示的每一位，判断每一位是否为 1，同时进行计数。

那问题就是如何通过位运算来识别到1，例如：00001001001000100001100010001001，首先我们注意到要识别到最低位的1，可以这么做：

```plain
00001001001000100001100010001001
 & 00000000000000000000000000000001
 = 00000000000000000000000000000001
```

也就说将原始数字和1进行&运算就能知道最低位是不是1了，那其他位置怎么算呢？

我们可以有两种思路，让1不断左移或者将原始数据不断右移。例如将原始数据右移就是：

```plain
00000100100100010000110001000100
 & 00000000000000000000000000000001
 = 00000000000000000000000000000000
```

很明显此时就可以判断出第二位是0，然后继续将原始数据右移就可以依次判断出每个位置是不是1了。因此是不是1，计算一下(n>>i) & 1就可以了，所以代码顺理成章：

```java
public int hammingWeight(int n) {
    int count = 0;
    for (int i = 0; i < 32; i++) {
        count += (n >> i) & 1;
    }
    return count;
}
int hammingWeight(int n) {
    int count = 0;
    for (int i = 0; i < 32; i++) {
        count += (n >> i) & 1;
    }
    return count;
}
def hammingWeight(n):
    count = 0
    for i in range(32):
        count += (n >> i) & 1
    return count
测试方法
n = 10  # 示例整数
print(hammingWeight(n))  # 输出结果为 2，因为 10 的二进制表示为 1010，其中有 2 个 1。
```

这个题也可以通过将1左移来实现的，该问题作为一个作业题，请你改造上面的代码来实现。

上面的代码写出来，这个题基本就达标了，但这还不是最经典的解法，我们继续分析：

按位与运算有一个性质：对于整数 n，计算n & (n−1) 的结果为将 n 的二进制表示的最后一个 1 变成 0。利用这条性质，令 n=n & (n−1)，则 n 的二进制表示中的 1 的数量减少一个。重复该操作，直到 n 的二进制表示中的全部数位都变成 0，则操作次数即为 n 的位 1 的个数。什么意思呢？我们继续看上面的例子：

```plain
n:       00000100100100010000110001000100
n-1:     00000100100100010000110001000011
n&(n-1)= 00000100100100010000110001000000
```

可以看到此时n&(n-1)的结果比n少了一个1，此时我们令n=n&(n-1)，继续执行上述操作：

```plain
n:       00000100100100010000110001000000
n-1:     00000100100100010000110000111111
n&(n-1)= 00000100100100010000110000000000
```

可以看到此时n&(n-1)的结果比上一个n又少了一个1，所以我们令n=n&(n-1)，循环执行上述操作，我们统计一下循环执行的次数就能得到结果了。

那循环该什么时候停下呢？很显然当n变成0的时候，否则说明数据里面还有1，可以继续循环。所以当且仅当 n=0 时，n 的二进制表示中的全部数位都是 0，代码也很好写了：

```java
public int hammingWeight(int n) {
    int count = 0;
    while (n != 0) {
        n = n & (n - 1);
        count++;
    }
    return count;
}
int hammingWeight(int n) {
    int count = 0;
    while (n != 0) {
        n = n & (n - 1);
        count++;
    }
    return count;
}
def hammingWeight(n):
    count = 0
    while n != 0:
        n = n & (n - 1)
        count += 1
    return count

测试方法：
print(hammingWeight(7))  # 输出: 3
print(hammingWeight(15)) # 输出: 3
```

上面两种解法，第一种的循环次数取决于原始数字的位数，而第二种的取决于1的个数，效率自然要高出不少，使用n = n & (n - 1)计算是位运算的一个经典技巧，该结论可以完美用到下面的题目中：

## 1.2 比特位计数

LeetCode338.给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 **1** **的个数** ，返回一个长度为 n + 1 的数组 ans 作为答案。

```plain
示例1：
输入：n = 2
输出：[0,1,1]
解释：0到n有 0 1 2 三个数字，每个数字含有1的个数分别为0 1 1 个，如下：
0 --> 0
1 --> 1
2 --> 10

示例2：
输入：n = 5
输出：[0,1,1,2,1,2]
解释：0到n有 0 1 2 3 4 5 六个数字，每个数字含有1的个数分别为0,1,1,2,1,2个，如下：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```

最直观的方法是对从 0 到 num 的每个数直接计算"一比特数"。每个int 型的数都可以用 32 位二进制数表示，只要遍历其二进制表示的每一位即可得到1 的数目。

```java
public int[] countBits(int num) {
    int[] bits = new int[num + 1];
    for (int i = 0; i <= num; i++) {
        for (int j = 0; j < 32; j++) {
            bits[i] += (i >> j) & 1;
        }
    }
    return bits;
}
int* countBits(int num) {
    int* bits = (int*)malloc((num+1) * sizeof(int));
    for (int i = 0; i <= num; i++) {
        bits[i] = 0;
        for (int j = 0; j < 32; j++) {
            bits[i] += (i >> j) & 1;
        }
    }
    return bits;
}
def countBits(num):
    bits = [0] * (num + 1)
    for i in range(num + 1):
        for j in range(32):
            bits[i] += (i >> j) & 1
    return bits
```

利用位运算的技巧，可以提升计算速度。按位与运算（&）的一个性质是：对于任意整数 x，令 x=x&(x−1)，该运算将 x 的二进制表示的最后一个 1 变成 0。因此，对 x 重复该操作，直到 x 变成0，则操作次数即为 x 的「一比特数」。

```java
public int[] countBits(int num) {
    int[] bits = new int[num + 1];
    for (int i = 0; i <= num; i++) {
        bits[i] = countOnes(i);
    }
    return bits;
}

public int countOnes(int x) {
    int ones = 0;
    while (x > 0) {
        x &= (x - 1);
        ones++;
    }
    return ones;
}
int countOnes(int x) {
    int ones = 0;
    while (x > 0) {
        x &= (x - 1);
        ones++;
    }
    return ones;
}

int* countBits(int num) {
    int* bits = (int*)malloc((num+1) * sizeof(int));
    for (int i = 0; i <= num; i++) {
        bits[i] = countOnes(i);
    }
    return bits;
}
def countOnes(x):
    ones = 0
    while x > 0:
        x &= (x - 1)
        ones += 1
    return ones

def countBits(num):
    bits = []
    for i in range(num + 1):
        bits.append(countOnes(i))
    return bits
```

有没有发现比特位计数和位1的个数计算规则完全一样？ 这就是为什么我们说研究清楚一道题，可以干掉一大票的题目。

## 1.3 颠倒无符号整数

LeetCode190 .颠倒给定的 32 位无符号整数的二进制位。 提示：输入是一个长度为32的二进制字符串。

```plain
示例1：
输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。

示例2：
输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
```

首先这里说是无符号位，那不必考虑正负的问题，最高位的1也不表示符号位，这就省掉很多麻烦。

我们注意到对于 n 的二进制表示的从低到高第 i 位，在颠倒之后变成第 31-i 位( 0≤i<32)，所以可以从低到高遍历 n 的二进制表示的每一位，将其放到其在颠倒之后的位置，最后相加即可。

看个例子，为了方便我们使用比较短的16位演示：

```plain
原始数据：1001 1111 0000 0110(低位)
第一步：获得n的最低位0，然后将其右移16-1=15位，得到：
reversed： 0*** **** **** **** 
n右移一位： 0100 1111 1000 0011

第二步：继续获得上面n的最低位1，然后将其右移15-1=14位，并与reversed相加得到：
reversed：01** **** **** **** 
n右移一位：0010 0111 1100 0001

继续，一直到n全部变成0：
```

理解之后，实现就比较容易了。由于 Java不存在无符号类型，所有的表示整数的类型都是有符号类型，因此需要区分算术右移和逻辑右移，在Java 中，算术右移的符号是 >>，逻辑右移的符号是 >>>。

```java
public int reverseBits(int n) {
    int reversed = 0, power = 31;
    while (n != 0) {
        reversed += (n & 1) << power;
        n >>>= 1;
        power--;
    }
    return reversed;
}
int reverseBits(int n) {
    int reversed = 0, power = 31;
    while (n != 0) {
        reversed += (n & 1) << power;
        n >>= 1;
        power--;
    }
    return reversed;
}
def reverseBits(n):
    reversed = 0
    power = 31
    while n != 0:
        reversed += (n & 1) << power
        n >>= 1
        power -= 1
    return reversed
```

本题的解法还有很多，例如还有一种分块的思想， n 的二进制表示有 32 位，可以将 n 的二进制表示分成较小的块，然后将每个块的二进制位分别颠倒，最后将每个块的结果合并得到最终结果。这分治的策略，将 n 的 32 位二进制表示分成两个 16 位的块，并将这两个块颠倒；然后对每个 16 位的块重复上述操作，直到达到 1 位的块。为了方便看清楚，我们用字母代替01，如下图所示。 

具体做法是：

下面的代码中，每一行分别将 n 分成16 位、8 位、4 位、2 位、1 位的块，即把每个块分成两个较小的块，并将分成的两个较小的块颠倒。同样需要注意，使用 Java 实现时，右移运算必须使用逻辑右移。由于是固定的32位，我们不必写循环或者递归，直接写：

```plain
  reverseBits(int n) {
        n = (n >>> 16) | (n << 16);
        n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);
        n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4);
        n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2);
        n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1);
        return n;
    }
```

这种方法在JDK、Dubbo等源码中都能见到，特别是涉及协议解析的场景几乎都少不了位操作。积累相关的技巧，可以方便面试，也有利于阅读源码。 

面试算法和工程算法

更多高频问题，仅限报名[【编程导航 - 算法通关村】](https://yuyuanweb.feishu.cn/wiki/J9qLwpv75iropZkXpmIcYrZ8nNM) 的同学可见，点击了解详情并参与.....



#  通关文牒

本篇介绍了位运算的几种经典应用，这些一般面试的时候是很难想出来的，但是如果提前准备过，则非常简单，针对上述任一题目写一篇博客，视为通关《算法通关村——》。
![](https://pic.yupi.icu/5563/202311220822450.png)
