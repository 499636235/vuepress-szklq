# 2.白银挑战—动态规划高频问题

动态规划是一个非常重要的问题，相关的题目也特别多，这里我们就一起学习几个难度适用的题目



| **关卡名**               | 掌握动态规划如何解题的 | 我会了✔️ |
| ------------------------ | ---------------------- | ------- |
| **内容**                 | 1.最少硬币数问题       |         |
| 2.最长连续递增子序列问题 |                        |         |
|                          | 3.最长递增子序列问题   |         |
|                          | 4.最少完全平方数问题   |         |
|                          | 5.再论青蛙跳问题       |         |



本文我们就来盘点那些常见的动态规划问题，本章除了最后两个题，其他都使用一维数组就可以了，因此我们每道题都要先明白，这个基表arr的含义是什么，如何更新的：

本章，我们首先通过详细的过程一步步来分析最少硬币数的问题，仔细观察每一步都是在做什么。代码如何从比较low的样子优化到比较合理。从2.2开始我们的讲解会更加精简。

# 1 最少硬币数 

LeetCode322.给你一个整数数组 coins ，表示不同面额的硬币，以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。

```plain
示例1：
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1

示例2：
输入：coins = [2,5, 7], amount = 27
输出：3 
解释：21 = 7 + 7 + 7
```

**画图分析**

这个题，其实使用上一章的回溯法也能做，问题就是效率太低了。假如coins = [2,5, 7], amount = 27，在求解过程中，每个位置都可以从{2,5,7}中选择 ，因此可以逐步将所有情况枚举出来，然后再找到要求的最少硬币数，图示如下：

![](https://pic.yupi.icu/5563/202311220834338.png)

通过上面的图，我们发现f[20]等已经存在多次重复计算了，这就是存在大量的重复计算问题，效率低，所以可以使用动态规划来优化。

另外貌似贪心也可以，直觉告诉我们尽量使用大的，例如假如要求的是27，此时应该先连续用7 + 7+7=21，最后的6没法了就用2，则就是3个7加3个2，一共6个，但我们可以这么做7+5+5+5+5=27 ，使用5枚硬币就够了，这就是贪心的思路，但对于本题就是错误的。

使用动态规划能同时满足效率和准确性的最佳，自然地，我们设状态f(x)=最少用f(x)枚硬币能拼出x。对应到上面基表就表示最少用arr[i]个硬币能表示出i来。我们先看上面给的示例1的情况：

![](https://pic.yupi.icu/5563/202311220834195.png)

上面图中，索引表示的是amount，而每个位置表示就是最少需要arr[i]个硬币就能拼出来。但是有些场景下可能不能将所有位置都能拼接出来的，例如示例2中的：

![](https://pic.yupi.icu/5563/202311220834206.png)

我们注意上面有些位是放的是M，表示的就是不能拼出来的意思。接下来我们就以coins={2,5,7}来详细分析如何一步步实现DP。

**第一步：确定状态和子问题**

什么是状态？前面介绍过，解动态规划的时候需要一个数组，状态就是这个数组的每个元素f[i]表示什么。

DP从思想上看仍然是递归，我们要找到将问题范围缩小的递推表达式，也就是状态转移方程。对于大部分DP的题目，先看最后一步的情况更容易分析出来，所以我们的武功心法第一条是从后向前找递归。

这里的最后一步就是：虽然我们不知道最优策略是什么，但是我知道最后得到最优策略一定是K枚硬币，a1，a2，...ak，而且面值加起来是27，而除掉ak这枚硬币，前面硬币加起来就是27-ak。此时我们得到:

![](https://pic.yupi.icu/5563/202311220834230.png)

这里貌似我们还不知道ak是多少？但是那一枚一定是2，5，7中的一个。

- 如果ak是2，那么f(27)应该是f(27-2)+1,加上最后这一枚硬币2。 f(25)+1
- 如果ak是5，那么f(27)应该是f(27-5)+1,加上最后这一枚硬币5。 f(22)+1
- 如果ak是7，那么f(27)应该是f(27-7)+1,加上最后这一枚硬币7。 f(20)+1

除此之外，没有其他可能了。那我们最后到底要使用哪一个呢？很简单，就是选上面三种情况最小的那个，也就是：

f(n):n是我们是要拼的数，这里f(n) 表示拼成n所需的最少硬币数

f(27)= min{ f(25)+1,f(22)+1,f(20)+1}

f(27)= min{ f(25),f(22),f(20)}+1

f(n)=min{f(n-2),f(n-5),f(n-7)}+1

f(27)=min{f(27-2)+1,f(27-5)+1,f(27-7)+1}

在上面的过程中，我们不关心前面的K-1枚硬币是怎么拼出27-ak的，前K-1步可能有一种拼法，也可能有100种，甚至我们也没确定ak和k是啥，但是能确定的是前面一定拼出了27-ak，并且此时使用的硬币总数m=k-1枚一定是最少的，否则就不是最优策略,这里本题的一个核心， 也是不太好理解的地方。

到此，要处理的子问题就是”最少用多少枚硬币可以拼出27-ak，而原始问题是"最少用多少枚硬币拼出27"。这样，我们就将原问题转化成了一个子问题，而且规模更小27-ak。

而至于最后一个ak，我们就是简单枚举了一下，要么是2，要么是5，要么是7，这就是局部枚举。而且到现在为止，我们也不知道到底用哪一个，唯一能确定的就是最后一个肯定是从2,5,7中选了一个，所以只是得到这样一个壳子：

f(27)=min{f(25)+1,f(22)+1,f(20)+1}

那接下来要怎么办呢？很简单，就是根据递归的思想再去算f(25)、f(22)和f(20)，例如计算f(20)就是:

f(20)=min{f(18)+1,f(15)+1,f(13)+1}

到这里仍然是不知道结果的，那就继续算，例如计算f(13)就是：

f(13)=min{f(11)+1,f(8)+1,f(6)+1}

到这里还是不知道结果，那就继续算，例如计算f(6)就是：

f(6)=min{f(4)+1,f(1)+1,f(-1)+1}

到这里很明显就非常容易计算了。

通过上面的例子，我们终于明白为什么找递推要从右向左，而计算的时候要从左向后了。

当然这里很明显f(-1)不符合要求的，那就设置为正无穷就行了。f(1)=也是正无穷，而f(4)=2，所以f(6)=2+1=3，然后继续计算最大的，最后就得到我们想要的结果。

**第二步：确定状态转移方程**

子问题确定之后，状态转移方程就很容易了，为了简化定义，我们设状态为f(x)=最少使用多少枚硬币拼出X。根据上面的分析，这里的ak，只能是2，5或者7。而我们要求的最少硬币数，就是求下面三个的最小值：

![](https://pic.yupi.icu/5563/202311220834566.png)

这个就是状态转移方程，在上一步我们已经分析出来了。

再往后，就是采用一样的套路将f(25)、f(22)和f(20)一起交给后续递归过程继续算。

**第三步：确定初始条件和边界**

很明显，本题的初始条件是: f[0]=0

对于上面的公式，有两个问题如果x-2，x-5，x-7，小于0怎么办？如果不能拼出x，就定义f[x]为正无穷，例如f[-1]=f[-2]=...=正无穷，表示拼不出1来。思考一下，这里为什么不能初始化为0？

当然这里有一点要注意，我们上面不可达用的是M，而不是Integer.MAX，因为这样的公式溢出了：

f(6)=min{2,Integer.MAX+1,Integer.MAX+1,}

我们可以使用amount来代替Integer.MAX

**第四步：按顺序计算**

开始执行上面的f[x]计算公式，f[x]=min{f[x-2]+1,f[x-5]+1,f[x-7]+1}

虽然推导我们是从后向前 ，但是计算我们一般是从前向后的，在第一步中已经解释过，我们的计算过程如下：

初始条件：f[0]=0

然后计算f[1],f[2],...f[27]

这样的好处是计算f[x]的时候，f[x-2],f[x-5],f[x-7]都已经计算到结果了，因此效率更高。

执行的结构图如下（f[x]表示最少用几个硬币和拼出X，无穷表示无法拼出）：

![](https://pic.yupi.icu/5563/202311220834249.png)

现在请你思考一下这里的数字是怎么逐步计算出来的。这里其实每一步计算都是尝试3种硬币，一共27步，但是与递归相比，没有任何重复计算。因此算法时间复杂度为27*3。而递归的时间复杂度远远大于该数。

在这里每一步都尝试三种硬币，一共27步，对应的也就是一维数组的大小。

可以看到，与递归相比没有任何重复计算，因此效率更高。

**第五步：代码实现**

经过上面的分析之后，我们接下来就要实现上面的逻辑。根据上面f[x]的公式，我们可以写出第一版的代码：

```java
//不能执行,仅仅做学习思考
int coinChange(int[] coins, int amount) {
    int max = amount + 1; Interge.MAX
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, max);
    dp[0] = 0;
    for (int i = 1; i <= amount; i++) {
        if(check(i,coins)){
            dp[i] = min(dp[i], dp[i - coins[0]] + 1,dp[i - coins[1]] + 1,dp[i - coins[2]] + 1);
        }   
    }
    return dp[amount] > amount ? -1 : dp[amount];
}

boolean check(int i,int []coins){
    // 这里要保证if里使用的i - coins[j]等大于零
    // 这里还要保证不越界，写起来比较复杂 ，我们理解功能即可 
}
```

上面的min()方法我们暂时不实现，反正是从中找最小的那个。但这个代码不太优雅，dp的计算太长了，我们可以通过下面的方式来调整一下：

```java
//不能执行,仅仅做学习思考
public int coinChange(int[] coins, int amount) {
    int max = amount + 1;
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, max);
    dp[0] = 0;
    for (int i = 1; i <= amount; i++) {
        if(check(i,coins) ){//简写
            dp[i] = min(dp[i], dp[i - coins[0]] + 1);
            dp[i] = min(dp[i], dp[i - coins[1]] + 1);
            dp[i] = min(dp[i], dp[i - coins[2]] + 1);
        }   
    }
    return dp[amount] > amount ? -1 : dp[amount];
}
boolean check(int i,int []coins){
    // 这里要保证if里使用的i - coins[j]等大于零
    // 这里还要保证不越界，写起来比较复杂 ，我们理解功能即可 
}
```

这样我们就可以通过三次计算dp分别来处理coins[]数组的情况。但是这么写仍然不好，如果coins[]数组比较大，if判断就会非常长。怎么办呢？好办，加个循环来解决。

最终代码如下：

```java
public static int coinChange(int[] coins, int M) {
    int max = M + 1;
    int[] dp = new int[M + 1];
    Arrays.fill(dp, max);
    dp[0] = 0;
    for (int i = 1; i <= M; i++) {
        for (int j = 0; j < coins.length; j++) {
            if (coins[j] <= i) {
                dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
            }
        }
    }
    return dp[M] > M ? -1 : dp[M];
}
def coinChange(self, coins, amount) :
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1 
int coinChange(vector<int>& coins, int M) {
    int max = M + 1;
    int dp[max];
    fill(dp, dp + max, max);
    dp[0] = 0;
    for (int i = 1; i <= M; i++) {
        for (int j = 0; j < coins.size(); j++) {
            if (coins[j] <= i) {
                dp[i] = min(dp[i], dp[i - coins[j]] + 1);
            }
        }
    }
    if (dp[M] > M) {
        return -1;
    }
    return dp[M];
}
```

这就是本题最终的实现方法。

这里虽然是递归，但是是通过循环+数组来实现的，这就是为了消除冗余加速计算。

**总结**

我们现在来总结一下求最值型DP的步骤：

1.确定状态和子问题，从最后一步开始（最优策略中使用的最后一枚硬币ak）推导f(n)与子问题之间的关系，然后将其化成子问题(最少的硬币拼出更小的面值27-ak)。

2.通过状态，我们可以得到状态转移方程：f[x]=min{f[x-2]+1,f[x-5]+1,f[x-7]+1}

3.处理初始条件和边界情况。f[0]=0,其他的如果不能拼出来就标记为f[X]=正无穷。

4.从小到大开始计算。这里就是从f[0]、f[1]、f[2]..向后计算。

# 2 最长连续递增子序列

LeetCode674.给定一个未经排序的整数数组，找到最长且连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

```plain
示例1：
输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7]也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。
```

对于本题，不用动态规划也可以解决，例如我们前面介绍的《滑动窗口》就可以。如果使用动态规划的话，我们仍然先手动画一下，看看数组变成什么样子：

![](https://pic.yupi.icu/5563/202311220834834.png)

很明显就是从前向后累计一下，如果不再是递增了，就将f[x]设置为1，然后继续向前走。

这种问题也称为序列型动态规划，给定一个序列或者网格，需要找到序列中某个/些子序列或者网格中的某条路径，要求满足某种性质最大/最小，求计数或者判断存在性问题。

**第一步：确定状态和子问题**

分析最后一步，对于最优策略，一定有最后一个元素a[j]。我们先考虑简单情况：

- 第一种情况：最优策略中最长连续上升子序列就是{a[j]}，答案是1。
- 第二种情况：子序列长度大于1，那么最优策略中a[j]前一个元素肯定是a[j-1]，这种情况一定是a[j-1]<a[j]的。

因为是最优策略，那么它选中的以a[j-1]结尾的连续上升子序列一定是最长的。

这里我们也得到了子问题：求以a[j-1]结尾的最长连续上升子序列，而本来是求以a[j]结尾的最长连续上升子序列。

状态：设f[j]=以a[j]结尾的最长连续上升子序列的长度。 

则转移方程就是：

![](https://pic.yupi.icu/5563/202311220834030.png)

注意上图中红色线前面的是表达式，后面是要满足的条件。

**第二步：初始条件和边界**

情况2必须满足：j>0,即a[j]前面至少还有一个元素 并且a[j]>a[j-1]满足单调性。

**第四步：按照顺序计算**

计算f[0]，f[1]，f[2]，...，f[n-1]

和硬币组合题不一样的是，最终答案不一定是f[n-1]，因为我们不知道最优策略中最后一个元素是哪个a[j]。所以答案是max{f[0]，f[1]，f[2]，...，f[n-1]}。

```java
public   int findLengthOfLCIS(int[] nums) {
    int[] dp = new int[nums.length];
    for (int i = 0; i < dp.length; i++) {
        dp[i] = 1;
    }
    int res = 1;
    for (int i = 0; i < nums.length - 1; i++) {
        if (nums[i + 1] > nums[i]) {
            dp[i + 1] = dp[i] + 1;
        }
        res = res > dp[i + 1] ? res : dp[i + 1];
    }
    return res;
}
def findLengthOfLCIS(self, nums: List[int]) -> int:
    if len(nums) == 0:
        return 0
    result = 1
    dp = [1] * len(nums)
    for i in range(len(nums)-1):
        if nums[i+1] > nums[i]: #连续记录
            dp[i+1] = dp[i] + 1
        result = max(result, dp[i+1])
    return result
int findLengthOfLCIS(vector<int>& nums) {
    if (nums.size() == 0) return 0;
    int result = 1;
    vector<int> dp(nums.size() ,1);
    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] > nums[i - 1]) { // 连续记录
            dp[i] = dp[i - 1] + 1;
        }
        if (dp[i] > result) result = dp[i];
    }
    return result;
}
```

# 3 最长递增子序列

LeetCode300.给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

```plain
示例1：
输入：nums = [10,9,2,5,3,7,101,1]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为4。
```

注意本题与上一题的区别就是没说一定是连续的，例如上面示例里2和7就不是连续的。本题该怎么做呢？我们还是先手动算一下看看：

![](https://pic.yupi.icu/5563/202311220834928.png)

我们看一下使用DP解决问题的方法：

**第一步：确定状态**

最后一步：对于最优的策略，一定有最后一个元素a[j]。

第一种情况：最优策略中最长上升子序列就是{a[j]}，答案是1。

第二种情况：子序列长度大于1，那么最优策略中a[j]前一个元素是a[i]，并且a[i]<a[j]

![](https://pic.yupi.icu/5563/202311220834021.png)

因为是最优策略，那么它选中的以a[i]结尾的上升子序列一定是最长的。

所以我们就得到子问题：因为不确定最优策略中a[j]前一个元素a[i]是哪一个，需要枚举每个i，求以a[j]结尾的最长上升子序列。化为子问题：i<j

状态：设f[j]=以a[j]结尾的最长上升子序列的长度

![](https://pic.yupi.icu/5563/202311220834262.png)

**第三步：初始条件和边界情况**

情况2必须满足：①i>=0;② a[j]>a[i]，也就是满足单调性。

**第四步：计算顺序**

计算f[0]、f[1]、f[2]、....f[n-1]，答案就是这些数中最大的那个。

本题的时间复杂度为O(n^2)，空间复杂度O(n)。

```java
public int lengthOfLIS(int[] A) {
    int n=A.length;
    if(n==0){
        return 0;
    }
    int []f=new int[n];
    int i,j,res=0;
    for(j=0;j<n;j++){
        f[j]=1;
        for(i=0;i<j;i++){
            if(A[i]<A[j]&&f[i]+1>f[j]){
                f[j]=f[i]+1;
            }
        }
        res=Math.max(res,f[j]);
    }
    return res;
}
def lengthOfLIS(self, nums):
    if not nums:
        return 0
    dp = []
    for i in range(len(nums)):
        dp.append(1)
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
int lengthOfLIS(vector<int>& A) {
    int n = A.size();
    if (n == 0) {
        return 0;
    }
    int f[n];
    int i, j, res = 0;
    for (j = 0; j < n; j++) {
        f[j] = 1;
        for (i = 0; i < j; i++) {
            if (A[i] < A[j] && f[i] + 1 > f[j]) {
                f[j] = f[i] + 1;
            }
        }
        res = max(res, f[j]);
    }
    return res + 1;
}
```

# 4 最少完全平方数

LeetCode279.给你一个整数 n ，返回和为n的完全平方数的最少数量。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

```plain
示例1：
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4

示例2：
输入：n = 13
输出：2
解释：13 = 4 + 9
 4 + 9
 4 4 4 1
 4 4 1 1 1 1 1 1
 4 1 1 1 1 1 1 1 1 1
```

这个题如果通过暴力来算，一定会超时，我们还是考虑如何通过DP来做。首先我们看一下手动画一下看看数组的变化：

![](https://pic.yupi.icu/5563/202311220834379.png)

**第一步：确定状态**

先看序列的最后一步：关注最优策略中最后一个完全平方数j^2，那么最后策略中n-j^2也一定被划分成最少的完全平方数之和。因此需要知道n-j^2最少被分成几个完全平方数之和，而原问题是求n最少被分成接完全而平方数之和，这就是子问题。

根据子问题，我们可以确定状态了：设f[i]表示i最少被分成几个完全平方数之和。

**第二步：确定状态转移方程**

设f[i]表示i最少被分成几个完全平方数之和。

![](https://pic.yupi.icu/5563/202311220834565.png)

**第三步：确定初始条件和边界条件**

初始条件：0被分成0个完全平方数之和。f[0]=0。

然后依次计算f[1],...，f[N]

答案就是f[N]。

```java
public int numSquares(int n) {
    int[] f = new int[n + 1];
    f[0] = 0;
    for (int i = 1; i <= n; i++) {
        f[i] = Integer.MAX_VALUE;
        for (int j = 1; j * j <= i; j++) {
            if (f[i - j * j] + 1 < f[i]) {
                f[i] = f[i - j * j] + 1;
            }
        }
    }
    return f[n];
}
def numSquares(n):
    f = [0] * (n+1)
    f[0] = 0
    for i in range(1, n+1):
        f[i] = sys.maxsize
        for j in range(1, int(i**0.5)+1):
            if f[i-j**2] + 1 < f[i]:
                f[i] = f[i-j**2] + 1
    return f[n]
int numSquares(int n) {
    int f[n + 1];
    f[0] = 0;
    for (int i = 1; i <= n; i++) {
        f[i] = 10000;
        for (int j = 1; j * j <= i; j++) {
            if (f[i - j * j] + 1 < f[i]) {
                f[i] = f[i - j * j] + 1;
            }
        }
    }
    return f[n];
}
```

# 5 再论青蛙跳

更多高频问题，仅限报名[【编程导航 - 算法通关村】](https://yuyuanweb.feishu.cn/wiki/J9qLwpv75iropZkXpmIcYrZ8nNM) 的同学可见，点击了解详情并参与.....



#  通关文牒

本文的重点是理解动态规划是如何解题的，写一篇文章，题目《算法通关村——透彻理解动态规划》就是通关了。


![](https://pic.yupi.icu/5563/202311220834681.png)
